$Id$
$Name$

Flexbackup to-do list
Some of these might not happen

Currently:
 - Check for mt blksize = factor of blksize
 - other FIXMEs in code

 - mbuffer testing w/ device (need mt_blksize not to be 0?)
 - mbuffer testing w/ remote
 - mbuffer testing w/ end of media

 - Test -test-tape-drive mod

 - Check old release for use_file + -erase.  nukes db entry for keyfile
   (devel too as well)
 - -erase for use_file wipes files+index+key?

 - Finish up -set / -dir
     test with tapes too
     how to spec dirs with spaces?

 - Exclude paths, not just expressions?  per-fs?

Cleanup/fix:
 - Better cleanup after error in backup
 - Use something besides script for second file in test-tape-drive
   (For problem with st0 <-> nst0, would never show up)
 - Clean up more $main:: vars, split into types or refactor code
 - Whole class of problems like:
    - Use dump combined flags (for older dumps that want abc not -a -b -c)
    - Not all finds have the -fstype flag (from $traverse_fs)
    - How to handle (use lowest common denominator flags?  sorta what's tried now)
 - When level > 9 and using files, -toc sorts it wrong (cosmetic nit)
 - When level > 9 and rm old logs/stamps, order is printed wrong (cosmetic nit)
 - If comp_log is changed, we don't nuke old logs that normally would be
   overwritten with ourselves if comp_log stayed the same. (cosmetic nit)
 - Try to refactor backup all/single, each fs, >1 tapes, etc.  Duplicated
     logic in some spots..
 - Fix afio w/null (FreeBSD printf can't spit out null char)
 - Delete deprecated sections

Misc:
 - Update README/faq/spec/lsm for new items changes since 1.0.2
     set/dir
     pkgdelta
     filelist
     mt_blksize
     example for -wday use
 - add faq on max size
 - add faq on mt erase taking forever / erase_rewind_only
 - Create mbuffer rpm. Add link/rpm for mbuffer
 - Do bfr again, maybe was blocking problem?
 - Make a manual page (AND other enchanced documentation, more than a README)
   someone made a good start or two:
     http://www.law.utulsa.edu:8080/users/bchapman/linuxnotes/flexbackup
     http://myezserver.com/downloads/mitel/howto/flexbackup-howto.html
     http://www.cyber-euskadi.com/howtos/contrib/flexbackup-restore-from-disk-howto.html
     how about french?  http://sgmf.free.fr/flexbackup_doc.html
 - Try against torture-test list:
     http://ftp.berlios.de/pub/star/testscripts/zwicky/testdump.doc.html
 - Update mt manpages collection
 - Get someone to do .debs?


Features to add:
 - Handle multi-volume backups (original idea w/ 'multibuf' never panned out)

      Found "multivol" program.
      Ack.  still not workable.  need edits to multivol...

      mbuffer can do this?

 - Make package delta work with BSD ports or debian pkgs

 - If we detect an error and are using tapes, do something intelligent
     to reposition tape, add another filemark, etc to get tape to known state
     and avoid the maybe-error in the index & what 'nextfile' is on the tape

 - smbtar?
     doable - overload type 'tar'. smbtar triggers with a fs spec of something like
               smb:user:pass@host/share:dir
     smbtar has "files newer than" option, test
     don't want password echoed
     no exclude from find
     top level of shares only?

 - Spiff up the contributed CGI program?

 - autoconf it (esp if we pkg multivol?)
   Make a multvol tar/rpm available 

 - Split main program; use separate libs for archiver types that are stored
   in different files?  downside: install then requires more than just program + conf file.

 - Do we want to count on perl (or flexbackup for that matter) being
     installed on remote machines?  We could do some built-in replacements
     for the 'find' for instance and make things more standardized. although
     keeping it simply built out of standard commandline utils is a big plus
     as well...

 - Make remote machine path overrides possible, that supercede others?

 - Make -extract -files for afio/cpio/zip recurse dirs
      dump/tar already to this. Actually just check that all act the same.

 - Interactive restore-like shell for types besides dump
      see notes below

 - Log tape sizes (output of buffer or dd or mt tell can be used?)

 - Stor lists of files backed up in a on-disk db (to help find what to
     restore from?). Actually now you can just 'zgrep filename
    /var/log/flexbackup/*' and that works pretty well.

 - Extract options to not overwrite existing files

 - Store the index db on the tapes?
      But we don't know the size ahead of time unless hard-limited resperved size.
      Updating db at the beginning of the tape will add tape-travel overhead for every backup.
      rewind->write loses the rest of the contents past the first file?

 - CD-ROM burning (or just .iso type?) for full backups? any?

 - gnuplot graphs of backup size/duration vs time (parse logfiles)

 - Encryption with gnupg?

 - Gnome driver/configurator utility
      a separate program that just manipulates flexbackup

 - "rsync" type for when using on-disk?

 - Make file-based backups able to use split for smaller archives?

-------------------------------------------------------------

Notes for cloning restore shell for afio/tar/cpio types)
Use perl readline module
(Maybe a seperate program or module that runs off a list fed to it)

1) do a listing
2) parse & put into data structures
3) mt bsf 1
4) then give a shell w/ all commands from regular dump
5) mark things for extraction
6) reopen archive & extract that list

Help from restore to jog my brain...

        ls [arg] - list directory
        cd arg - change directory
        pwd - print current directory
        add [arg] - add `arg' to list of files to be extracted
        delete [arg] - delete `arg' from list of files to be extracted
        extract - extract requested files
        setmodes - set modes of requested directories
        quit - immediately exit program
        what - list dump header information
        verbose - toggle verbose flag (useful with ``ls'')
        help or `?' - print this list
If no `arg' is supplied, the current directory is used


Local Variables:
mode: flyspell
end:
