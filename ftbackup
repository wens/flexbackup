#!/usr/bin/perl -w
######################################################################
#
# Edwin Huffstutler, <edwinh@computer.org>
# $Id$
#
# Script to deal with running dump/restore with ftape
# I did this to to help automate my life, keep standard logs, etc.
# Also uses "vtblc" to label contents of dump tapes
#
# USAGE:
#
#  ftbackup -help     : this message
#  ftbackup -list     : list tape contents
#  ftbackup -restore  : restore from current tape position
#                      into your current working directory
#  ftbackup -compare  : compare archive at current tape position
#                      with the files on the system
#  ftbackup -fs all      : dump all filesystems, level 0
#  ftbackup -fs <x>     : dump filesystem <fs>, level 0
#  ftbackup -fs all -level <n>  : dump all filesystems, level n
#  ftbackup -fs <x> -level  <n> : dump filesystem <fs>, level n
#
# NOTE: Level 0 backups assume a new tape - will trigger
# tape retension and erasure.  Other level dumps move tape to
# current end of data and start the dump there
#
# Log files are of the format <prefix><fs>.<level>.<mmddyy>
# Lower-level dumps will wipe out all higher-level log files in
# the log directory for that filesystem.
#
# This script calls "ftmt", "dump", and "restore"; it also makes use
# of "vtblc" from the contrib directory of ftape-3.04
#
######################################################################

#
# CONFIGURE
# Edit this section
#

$archivetype = "afio";

# List the filesystems you wish to dump for "all"
# Just a simple space-separated list
# remote filesystems should denoted as "host:dir"
# $filesystems = "/ /usr /home";
$filesystems	= "/etc goliath:/etc";

# Log files
$prefix	= "";			# log files will start with this prefix
$logdir	= "/var/log/backup";	# directory where log files will be stored

$stampdir	= "/var/log/backup/timestamps";

# Tape parameters
$device		= "/dev/nqft0";	# device to dump to (non-rewinding)
$rawdevice	= "/dev/rawft0";# raw version of the above
$blksize	= "10";		# blocksize (k) to use

# For "afio" only
$buffer	= "500";		# Number of blocks to buffer

# For "dump" only
$length	= "3100000";		# estimated tape size (k). This number doesn't really
                            # do much but help "dump" get size estimates

#
# End of configuration section
#
######################################################################

use Getopt::Long;
use English;

# No output buffering
$OUTPUT_AUTOFLUSH = 1;

%opt = ();
if (! &GetOptions(\%opt,"help","mode=s","dir=s","level=i")) {
    &usage();
    exit(0);
}

# Give usage message
if (defined($opt{'help'})) {
    &usage();
    exit(0);
}


# Get date
chomp($date=`date +%Y%m%d`);

# Set blocksize if not default
if ($blksize != 10) {
    $_ = $blksize * 1024;
    system("ftmt -f $device setblk $_");
    if ($?) {
	die("Error from ftmt setblk, exiting...\n");
    }
}

$what = $ARGV[0];

if (defined($opt{'restore'})) {

    # If the 1st arg is "restore", just run restore and exit
    exec("restore -v -i -b $blksize -f $device");
    die "Failed exec of restore";

} elsif (defined($opt{'compare'})) {

    # If the 1st arg is "compare", check dump vs. filesystem
    exec("restore -C -b $blksize -f $device");
    die "Failed exec of restore";

} elsif (defined($opt{'list'))) {

    # Just list contents
    system("ftmt -f $device rewind");
    if ($?) {
	die("Error from ftmt, exiting...\n");
    }
    exec("vtblc -p -f $rawdevice");
    die "Failed exec of vtblc";

}

# Get dump level...
if (!defined($opt{'level'})) {
    $opt{'level'} = 0;
}

# Die if no fs specified
if (!defined($opt{'fs'})) {
    &usage();
    exit(0);
}

# Figure out log file name
$tag = $opt{'fs'};
if ($opt{'fs'} ne 'all') {
    $tag =~ s:^/::;
    $tag =~ s:/:-:g;
    if ($tag eq '') {
	$tag = 'root';
    } elsif ($tag =~ m/^(.+):-$/) {
	$tag = "$1:root";
    }
    if (! -d "$opt{'fs'}" && ($opt{'fs'} !~ m/^.+:.+/)) {
	print "Can't dump $opt{'fs'}, no such directory\n";
	exit(1);
    }
}


# Empty log file
$log = "$logdir/$prefix" . $tag . "." . $level . "." . $date;
if (! open(LOG,">$log")) {
  die "Can't write to $log: $!\n";
}
close(LOG);


# Remove old incremental log files
# ("old" = any higher-numbered logs for this "tag")
opendir(DIR,"$logdir") or die("Can't open logdir: $!\n");
@files = readdir(DIR);
foreach (@files) {
    next if (! m/^$prefix$tag\.([0-9])\.([0-9]+)$/);
    if ($1 > $level) {
	print "Removing old level $1 log of $opt{'fs'} ($date)\n";
	unlink("$logdir/$_") or warn("Can't remove $_: $!\n");
    }
}
close(DIR);


##########################
#
# Main dump routine
#
##########################
&log('Script version: $Id$ ');
&log("Doing level $level backup of $opt{'fs'} using $archivetype");
if ($opt{'fs'} eq 'all') {

    # All filesystems
    if ($level eq "0") {
	# Level zero - rewind and erase a new tape
	&log('Retensioning tape...');
	&mt('retension');
	&log('Erasing tape...');
	&mt('erase');
	$nextfile = 0;

    } else {
	# Incremental dump - list what's on it, then go to end of tape
	$nextfile = &contents();
	&log('Making sure tape is at end of data...');
	&mt('eom');
    }

    # Iterate over the filesystems and back 'em up
    foreach (split(/\s+/,$filesystems)) {
	&backup($archivetype,$_,$nextfile);
	$tag{$nextfile} = "$archivetype $_ ($level)";
	$nextfile++;
    }

    &line();
    &log('Updating table of contents...');
    &mt('rewind');
    foreach (keys %tag) {
	&tag($_,$tag{$_});
    }

} else {

    # Just one filesystem.  list what's on the tape first
    $nextfile = &contents();
    &log('Making sure tape is at end of data...');
    &mt('eom');
    &backup($archivetype,$opt{'fs'},$nextfile);
    &line();
    &log('Updating table of contents...');
    &mt('rewind');
    &tag($nextfile,"$archivetype $opt{fs} ($level)");
}

# Print out new contents
&contents();

exit(0);


######################################################################
# Rewind & print TOC using vtblc
# returns an integer that is the next file number
######################################################################
sub contents {
    my($output,$filenumber);
    &mt('rewind');
    &log('');
    $output=`vtblc -p -f $rawdevice 2>&1`;
    &log($output);
    &log('');
    $filenumber = -1;
    foreach (split("\n",$output)) {
        # Nr  Id          Label
        #-------------------------------
        #  0 VTBL "/var (level 9)
	next if m/^\s+Nr\s+/;
	next if m/^----------/;
	if (m/^\s+(\d+)\s+\S+\s+\"/) {
	    $filenumber = $1;
	}
    }
    $filenumber++;
    return($filenumber);
}

######################################################################
# Modify a table of contents entry
######################################################################
sub tag {
    my($filenum,$title) = @_;
    system("vtblc -f $rawdevice -# $filenum -m date -m label=\'$title\'");
}

######################################################################
# Backup a filesystem
######################################################################
sub backup {

    my($type,$dir,$filenum) = @_;
    my($string,$host,$tapehost);

    if ($type eq 'dump') {
	$string = &backup_dump($dir,$filenum);
    } elsif ($type eq 'afio') {
	$string = &backup_afio($dir,$filenum);
    } elsif ($type eq 'tar') {
	$string = &backup_tar($dir,$filenum);
    } else {
	die;
    }

    &line();
    &log("Running \"$string\"");
    &log("Backup will be file number $filenum");
    &line();
    system("$string 2>&1 | tee -a $log");
    if ($?) {
	&log("Error from $type backup, exiting....\n");
	exit(1);
    }
    &line();
    system("touch $stampdir/$dir.$level")
    &mt('getsize');
}


######################################################################
# Return command to backup a filesystem using dump
######################################################################
sub backup_dump {
    my($dir,$filenum) = @_;
    my($string,$host,$tapehost);

    if ($dir =~ s/^(.+):(.+)$/$2/) {
	$host = $1;
	chomp($tapehost = `hostname`);
	$string = "rsh $host \"/sbin/rdump $level"."uBbf $length $blksize $tapehost:$device $dir\"";
    } else {
	$string = "dump $level"."uBbf $length $blksize $device $dir";
    }
    return($string);
}


######################################################################
# Return command to backup a filesystem using compressed afio
######################################################################
sub backup_afio {
    my($dir,$filenum) = @_;
    my($string,$host,$tapehost);

    if ($dir =~ s/^(.+):(.+)$/$2/) {
	$host = $1;
	chomp($tapehost = `hostname`);
	$string = "cd $dir; find . -xdev -print";
	$string = "rsh $host -n \"$string | afio -o -Z -v -b $blksize" . "k -c $buffer -B $tapehost:$device\"";
    } else {
	$string = "cd $dir ; find . -xdev -print";
	$string = "$string | afio -o -Z -v -b $blksize" . "k -c $buffer -B $device";
    }
    return($string);
}


######################################################################
# Return command to backup a filesystem using tar
######################################################################
sub backup_tar {
    my($dir,$filenum) = @_;
    my($string,$host,$tapehost);

    if ($dir =~ s/^(.+):(.+)$/$2/) {
	$host = $1;
	chomp($tapehost = `hostname`);
	$string = "rsh $host \"tar -z --block-compress -c -v -l --totals -f $tapehost:$device $dir\"";
    } else {
	$string = "rsh $host \"tar -z --block-compress -c -v -l --totals -f $device $dir\"";
    }
    return($string);
}


######################################################################
# Echo message to screen and log
######################################################################
sub log {
    my($msg) = @_;
    print "$msg\n";
    open(LOG,">>$log");
    print LOG "$msg\n";
    close(LOG);
}

######################################################################
# Echo a line to both screen and log
######################################################################
sub line {
    print "----------------------------------------\n";
    open(LOG,">>$log");
    print LOG "----------------------------------------\n";
    close(LOG);
}

######################################################################
# Do a tape operation
######################################################################
sub mt {
    my($operation) = @_;
    system("ftmt -f $device $operation 2>&1 | tee -a $log");
    if ($?) {
	&log("Error from ftmt, exiting....\n");
        exit(1);
    }
}

######################################################################
# Print usage summary from the header
######################################################################
sub usage {
    open(FILE,"$0") or die "Can't open $0: $!\n";
    while(<FILE>) {
	last if (m/^\#\s+USAGE:/);
    }
    while(<FILE>) {
	last if (m/^\#\#\#\#\#\#\#/);
	s/^\#//;
	print;
    }
    close(FILE);
}
