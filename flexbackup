#!/usr/bin/perl -w
######################################################################
#
# Edwin Huffstutler, <edwinh@computer.org>
# $Id$
# $Name$
#
#         >>>> See the README file <<<<
#
# USAGE:
#
#  flexbackup -help                : this message
#
#  flexbackup -fs all              : backup all filesystems, level 0
#  flexbackup -fs <x>              : backup filesystem <x>, level 0
#  flexbackup -fs all -level <n>   : backup all filesystems, level n
#  flexbackup -fs <x> -level <n>   : backup filesystem <x>, level n
#
#  flexbackup -list                : list files in archive at current
#                                    tape position
#
#  flexbackup -extract             : restore from current tape position
#                                    into your current working directory
#
#  flexbackup -compare             : compare archive at current tape position
#                                    with the files in your current directory
#
#  flexbackup -restore             : as above, but interactive restore
#                                    (dump type only for now)
#
#  flexbackup [operation] file     : if archiving to files rather than a device,
#                                    list/extract/compare/restore options take
#                                    a filename argument
#
#  flexbackup -toc                 : list tape table of contents
#                                    with Linux ftape only
#
#  flexbackup [opt] -c <file>      : use <file> instead of /etc/flexbackup.conf
#                                    for configuration
#
#  flexbackup [opt] -type <x>      : override $type from config file
#
#  flexbackup [operation] -reten   : force a retension before any operation
#  flexbackup -fs <x> -erase       : force a rewind/erase before backup
#  flexbackup -fs all -noreten     : don't retension for level 0 "all" backups
#  flexbackup -fs all -noerase     : don't rewind/erase for level 0 "all" backups
#
#  flexbackup [opt] -n             : don't run actual dump or mt commands
#  flexbackup [opt] -d 'var=val'   : override config file setting of $var
#  flexbackup -version             : show version
#
######################################################################

use Getopt::Long;
use English;
use strict;

# No output buffering
$OUTPUT_AUTOFLUSH = 1;

package main;

%main::opt = ();
if (! &main::GetOptions(\%main::opt,
                        "help",
                        "c=s",
                        "level=i",
                        "fs=s",
                        "extract:s",
                        "restore:s",
                        "list:s",
                        "compare:s",
                        "toc",
                        "type=s",
                        "noreten",
                        "noerase",
                        "erase",
                        "reten",
                        "version",
                        "n",
                        "d=s%"
		  )) {
    &usage();
    exit(0);
}

# Give usage message
if (defined($main::opt{'help'})) {
    &usage();
    exit(0);
}

# Version
if (defined($main::opt{'version'})) {
    print ('$Id$ ');
    print "\nflexbackup version " . &versionstring();
    exit(0);
}


# Get/read config file
print "\nflexbackup version " . &versionstring() . "\n";
&readconfigfile();

# Set OS type
chomp($main::uname = `uname -s`);

# Sanity check
&optioncheck();

# Get current date string
$main::date = &current_time("short");

# Decide what to do
if (defined($main::opt{'restore'})) {

    &restore_routine();

} elsif (defined($main::opt{'extract'})) {

    &extract_routine();

} elsif (defined($main::opt{'compare'})) {

    &compare_routine();

} elsif (defined($main::opt{'list'})) {

    &list_routine();

} elsif (defined($main::opt{'fs'})) {

    &backup_routine();

} elsif (defined($main::opt{'toc'})) {

    if ($cfg::ftape eq 'true') {
        &mt("generic-blksize $main::mt_blksize");
	&mt('rewind');
	exec("vtblc -p -f $cfg::rawdevice");
	die("Failed exec of vtblc");
    } else {
	die("-toc only implemented for ftape under Linux");
    }

}

exit(0);

######################################################################
# Backup
######################################################################
sub backup_routine {

    my @files;
    my $label;
    my $list;
    my $tapecounter = 0;
    my $olddate;
    my %oldlogs;
    my $fs;

    # Get backup level...
    if (defined($main::opt{'level'})) {
        $main::level = $main::opt{'level'};
    } else {
        $main::level = 0;
    }

    # Get rid of trailing /
    $main::opt{'fs'} = &nuke_trailing_slash($main::opt{'fs'});

    # Figure out log file name & empty log file
    $label = &get_label($main::opt{'fs'});
    $main::log = "$cfg::logdir/$cfg::prefix$label.$main::level.$main::date";
    if (! open(LOG,">$main::log")) {
        die "Can't write to $main::log: $OS_ERROR";
    }
    close(LOG);

    &line();
    &mt("generic-blksize $main::mt_blksize");

    # Remove old stamp files
    # ("old" = any higher-numbered stamps for this label)
    opendir(DIR,"$cfg::stampdir") or die("Can't open $cfg::stampdir: $OS_ERROR");
    @files = readdir(DIR);
    foreach (reverse sort @files) {
        next if (! m/^$cfg::sprefix$label\.([0-9])$/);
        if ($1 > $main::level) {
            print "| Removing old level $1 timestamp of $main::opt{fs}\n";
            unlink("$cfg::stampdir/$_") or warn("Can't remove $_: $OS_ERROR");
        }
    }
    close(DIR);

    # Remember old log files (will remove at end of job)
    # ("old" = any higher-numbered logs for this label)
    opendir(DIR,"$cfg::logdir") or die("Can't open cfg::logdir: $OS_ERROR");
    @files = readdir(DIR);
    foreach (reverse sort @files) {
        next if (! m/^$cfg::prefix$label\.([0-9])\.([0-9]+)(\.gz|\.bz2)?$/);
        $olddate = $2;
        if ($1 > $main::level) {
            $oldlogs{"$cfg::logdir/$_"} = $1 . "|" . $olddate;
        }
    }
    close(DIR);


    ##########################
    #
    # Main backup routine
    #
    ##########################
    # Spew some info
    $_ = &current_time();
    &log("| Current time: $_");
    &log("| Doing level $main::level backup of $main::opt{fs} using $cfg::type");

    if ($main::opt{'fs'} eq 'all') {

        foreach $list (@cfg::filesystems) {

            if ($main::level == 0) {

                &log("| Tape \#$tapecounter filesystems = $list");

                # All
                # Level zero - rewind and erase a new tape
                if (!defined($main::opt{'noreten'})) {
                    &log('| Retensioning tape...');
                    &mt('retension');
                }
                if (!defined($main::opt{'noerase'})) {
                    $main::nextfile = 0;
                    &log('| Rewinding & erasing tape...');
                    &mt('rewind','erase');
                }

            } else {

                &log("| Filesystems = $list");

                # All
                # Incremental backup - list what's on it, then go to end of tape
                if (!defined($main::opt{'erase'})) {
                    $main::nextfile = &contents();
                    &log('| Making sure tape is at end of data...');
                    &mt('generic-eod');
                } else {
                    $main::nextfile = 0;
                    &log('| Rewinding & erasing tape...');
                    &mt('rewind','erase');
                }

            }                   # end level == 0 (inside foreach fs, inside all)

            # Show tape position
            &line();
            &mt('generic-query');

            # Iterate over the filesystems and back 'em up
            foreach $fs (split(/\s+/,$list)) {

                # Get rid of trailing /
                $fs = &nuke_trailing_slash($fs);

                &backup($fs);
                $main::nextfile++;
            }

            # Prompt for new tape if more than one set in list & level 0
            if ($main::level == 0) {
                if ($tapecounter < $main::num_tapes) {

                    # Rewind
                    &line();
                    &log("| Rewinding...");
                    &mt('rewind');
                    &update_toc();
                    &line();

                    $tapecounter++;
                    if (!defined($main::use_file)) {
                        print "\n";
                        while(1) {
                        print "---> Insert tape \#$tapecounter (enter y to continue) ";
                            chomp($_ = <STDIN>);
                            last if ($_ =~ m/^y/i);
                        }
                        print "\n";
                        &line();
                    }
                }               # end not at last tape
            }                   # end level == 0 (inside foreach fs, inside all)
        }                       # end foreach fs (inside all)

    } else {

        # Just one filesystem
        if (defined($main::opt{'reten'})) {
            &log('| Retensioning tape...');
            &mt("retension");
        }

        if (defined($main::opt{'erase'})) {
            $main::nextfile = 0;
            &log('| Rewinding & erasing tape...');
            &mt('rewind','erase');
        } else {
            $main::nextfile = &contents();
            &log('| Making sure tape is at end of data...');
            &mt('generic-eod');
        }

        &line();
        &mt('generic-query');

        &backup($main::opt{'fs'});

    } # end all or single fs

    # Rewind
    &line();
    &log("| Rewinding...");
    &mt('rewind');
    &update_toc();
    &line();

    # Print out new contents
    &contents();

    # compress log file
    if ($cfg::comp_log ne 'false') {
        &line("logonly");
        print "| Compressing log file ($main::log)\n";
        system("$cfg::comp_log -f $main::log");
        if ($CHILD_ERROR) {
            warn("error compressing log file\n");
        }
        undef $main::log;
    }

    # Actually remove the old logs files now that we are done
    foreach (sort keys %oldlogs) {
        my ($lev,$d) = split(/\|/,$oldlogs{$_});
        print "| Removing old level $lev log of $main::opt{fs} ($d)\n";
        unlink("$_") or warn("Can't remove $_: $OS_ERROR\n");
    }

    &line();
    exit(0);

}

######################################################################
# Rewind & print TOC using vtblc
# returns an integer that is the next file number
######################################################################
sub contents {

    my $output;
    my $filenumber;

    if ($cfg::ftape eq "true") {
        &mt('rewind');
        &log('');
        $output=`vtblc -p -f $cfg::rawdevice 2>&1`;
        &log($output);
        &log('');
        $filenumber = -1;
        foreach (split("\n",$output)) {
            # Nr  Id          Label
            #-------------------------------
            #  0 VTBL "/var (level 9)
            next if m/^\s+Nr\s+/;
            next if m/^----------/;
            if (m/^\s+(\d+)\s+\S+\s+\"/) {
                $filenumber = $1;
            }
        }

    } else {

        $filenumber = 0;
    }

    $filenumber++;
    return($filenumber);
}

######################################################################
# Modify a table of contents entry
######################################################################
sub tag {

    my $filenum = shift(@_);
    my $title = shift(@_);

    system("vtblc -f $cfg::rawdevice -# $filenum -m date -m label=\'$title\'");

}

######################################################################
# Backup a filesystem
######################################################################
sub backup {

    my $dir = shift(@_);
    my $title;
    my @cmds;
    my $cmd;
    my $localdir = $dir;
    my $label = &get_label($dir);
    my $echo;
    my $host;

    &line();

    if ($localdir =~ s/^(.+):(.+)$/$2/) {
	$main::remote = $1;
	chomp($main::tapehost = `hostname`);
        if ($main::tapehost eq $main::remote) {
            die("Remote host and this host are the same! no banana for you!");
        }

    } else {
        $main::remote = '';
    }

    # Create file name if writing to a file
    # (config file's $device points to a dir in this case)
    if (defined($main::use_file)) {
        $_ = $main::date . "." . $main::level . "." . $cfg::type;
        if ($cfg::type =~ m/^(tar|dump|cpio)$/) {
            if ($cfg::compress eq "gzip") {
                $_ .= ".gz";
            } elsif ($cfg::compress eq "bzip2") {
                $_ .= ".bz2";
            }
        } elsif ($cfg::type eq "afio") {
            # tag these a little different, the archive file itself isn't a
            # .gz or .bz2, but the files in it are....
            if ($cfg::compress eq "gzip") {
                $_ .= "-gz";
            } elsif ($cfg::compress eq "bzip2") {
                $_ .= "-bz2";
            }
        }
        $main::device = $cfg::device . "/" . $label . "." . $_;
    }

    # Just get the date for now; don't write the timestamp
    # Until after the backup has run
    $main::date_at_start = &current_time();

    # Label for this archive
    $host = `hostname`;
    chomp($host);
    $_ = $cfg::compress;
    $_ =~ s/false//;
    $title = "level $main::level $dir $main::date_at_start $cfg::type+$_ flexbackup on $host";
    $title =~ s/\+ //;
    $main::title{$main::nextfile} = $title;

    # If we started with level 0, and "all", and -noerase not given,
    # we know the file number, since we erased the tape
    # (or if using ftape/vtblc, since we can find the file number)
    # (or if we had -erase on the commandline)
    if ((($main::opt{'fs'} eq "all") and ($main::level eq "0") and (!defined($main::opt{'noerase'})))
        or
        ($cfg::ftape eq "true")
        or
        ($main::opt{'erase'})) {
        &log("| File number: $main::nextfile");
    }

    &log("| Backup of: $dir");
    if ($cfg::type eq 'dump') {
	@cmds = &backup_dump($label,$localdir);
    } elsif ($cfg::type eq 'afio') {
	@cmds = &backup_afio($label,$localdir,$title);
    } elsif ($cfg::type eq 'tar') {
	@cmds = &backup_tar($label,$localdir,$title);
    } elsif ($cfg::type eq 'cpio') {
	@cmds = &backup_cpio($label,$localdir,$title);
    }

    # Enough fooling around... run it.  well, print it first.
    foreach (@cmds) {
        s/\s+/ /g;              # replace multiple spaces
        $echo = $_;
        # format for nice printing
        $echo =~ s/(&&|;|\|)\s+/\\\n| $1 /g;
        &log("| $echo");
    }
    &line();
    if (!defined($main::opt{'n'})) {
        foreach $cmd (@cmds) {
            system("($cmd) 2>&1 | tee -a $main::log");
            if ($CHILD_ERROR) {
                &log("$cfg::type: error from backup, exiting");
                &log("offending command: $cmd");
                exit(1);
            }
        }
    } else {
        &log("(debug) command output would be here");
    }
    &line();

    # Create timestamp file, but use date from before the backup started
    # so next time we will catch files that might have been toucehd during the run
    $_ = &current_time();
    &log("| Timestamp $cfg::sprefix$label.$main::level: $main::date_at_start");
    &log("| Current time: $_");
    system("touch -t $main::date_at_start $cfg::stampdir/$cfg::sprefix$label.$main::level");
    &line();

    # tar is causing me fits; mt right after archive operations is giving i/o errors
    if ($cfg::type eq 'tar') {
        sleep 10;
    }

    # Show where we are on the tape
    &mt('generic-query');

}

######################################################################
# Return command to backup a filesystem using dump
######################################################################
sub backup_dump {

    my $label = shift(@_);
    my $dir = shift(@_);
    my @cmds;
    my $archive_cmd;
    my $tmpstamp = "/tmp/refdate.$$";
    my $len_flag = $cfg::dump_length;

    $_ = &get_last_date($label);
    push(@cmds,&maybe_remote_cmd("touch -t $_ $tmpstamp"));

    if ($cfg::exclude_expr ne '') {
        &log("| Note: \$exclude_expr is ignored for dump");
    }

    $archive_cmd  = "dump -$main::level ";
    $archive_cmd .= "-b $cfg::blksize ";
    $archive_cmd .= "-u ";
    $archive_cmd .= "$main::dump_len_flag ";
    $archive_cmd .= "-f - $dir | $main::z";
    if ($main::remote) {
        $archive_cmd .= "$main::buffer_cmd | ";
    }
    $archive_cmd .= &maybe_remote_cmd("$main::buffer_cmd $main::buffer_flags -o $main::device",'"',$main::tapehost);

    push(@cmds,&maybe_remote_cmd($archive_cmd));
    push(@cmds,&maybe_remote_cmd("rm -f $tmpstamp"));

    return(@cmds);

}

######################################################################
# Return command to backup a filesystem using afio
######################################################################
sub backup_afio {

    my $label = shift(@_);
    my $dir = shift(@_);
    my $title = shift(@_);
    my @cmds;
    my $archive_cmd = '';
    my $tmpstamp = "/tmp/refdate.$$";
    my $tmpnocompress = "/tmp/nocompress.$$";

    $_ = &get_last_date($label);
    push(@cmds,&maybe_remote_cmd("touch -t $_ $tmpstamp"));

    $archive_cmd .= "cd $dir && ";
    $archive_cmd .= "(echo //--$tmpstamp $title && ";
    $archive_cmd .= "find . -xdev -newer $tmpstamp ";
    $archive_cmd .= $main::exclude_flag;
    $archive_cmd .= "-print0) | ";
    $archive_cmd .= "afio -o ";

    # list of file exenstions to not compress
    if (($cfg::compress ne "false") and ($cfg::afio_nocompress_types ne "")) {
        push(@cmds,&maybe_remote_cmd("echo \"$cfg::afio_nocompress_types\" > $tmpnocompress"));
        $archive_cmd .= "-E $tmpnocompress ";
    }

    $archive_cmd .= "-0 ";
    $archive_cmd .= "-z ";
    $archive_cmd .= "-s 0 ";
    $archive_cmd .= "-b $main::afio_blksize ";
    $archive_cmd .= "$main::afio_z_flag $main::afio_verb_flag $main::afio_bnum_flag - | ";
    if ($main::remote) {
        $archive_cmd .= "$main::buffer_cmd | ";
    }
    $archive_cmd .= &maybe_remote_cmd("$main::buffer_cmd $main::buffer_flags -o $main::device",'"',$main::tapehost);

    push(@cmds,&maybe_remote_cmd($archive_cmd));
    push(@cmds,&maybe_remote_cmd("rm -f $tmpstamp"));

    if (($cfg::compress ne "false") and ($cfg::afio_nocompress_types ne "")) {
        push(@cmds,&maybe_remote_cmd("rm -f $tmpnocompress"));
    }

    return(@cmds);

}

######################################################################
# Return command to backup a filesystem using cpio
######################################################################
sub backup_cpio {

    my $label = shift(@_);
    my $dir = shift(@_);
    my $title = shift(@_);
    my @cmds;
    my $archive_cmd;
    my $tmpstamp = "/tmp/refdate.$$";

    $_ = &get_last_date($label);
    push(@cmds,&maybe_remote_cmd("touch -t $_ $tmpstamp"));

    # Kludge a title for cpio by replacing / with - in the title
    # then touch a file in the dir we are going to back up.
    $title =~ s%/%-%g;
    push(@cmds,&maybe_remote_cmd("touch \'$dir/$title\'",'"'));

    $archive_cmd .= "cd $dir && ";
    $archive_cmd .= "find . -xdev -newer $tmpstamp ";
    $archive_cmd .= $main::exclude_flag;
    $archive_cmd .= "-print0 | ";
    $archive_cmd .= "cpio -o ";
    $archive_cmd .= "-0 ";
    $archive_cmd .= "-H $cfg::cpio_format ";
    $archive_cmd .= "-C $main::cpio_blksize ";
    $archive_cmd .= "$main::cpio_verb_flag ";
    $archive_cmd .= "| $main::z";
    if ($main::remote) {
        $archive_cmd .= "$main::buffer_cmd | ";
    }
    $archive_cmd .= &maybe_remote_cmd("$main::buffer_cmd $main::buffer_flags -o $main::device",'"',$main::tapehost);

    push(@cmds,&maybe_remote_cmd($archive_cmd));
    push(@cmds,&maybe_remote_cmd("rm -f \'$dir/$title\'",'"'));
    push(@cmds,&maybe_remote_cmd("rm -f $tmpstamp"));

    return(@cmds);

}

######################################################################
# Return command to backup a filesystem using tar
######################################################################
sub backup_tar {

    my $label = shift(@_);
    my $dir = shift(@_);
    my $title = shift(@_);
    my @cmds;
    my $archive_cmd;
    my $date_flag;
    my $tmpexclude = "/tmp/exclude.$$";
    my $exclude_flag = '';

    # With this one we don't have to put a stampfile on the remote system
    # since we only need the date string
    if ($main::level == 0) {
        &get_last_date($label); # Just to print dates, dont' need result
        $date_flag = "";
    } else {
        $_ = &get_last_date($label,'readable');
        $date_flag = "-N \"$_\" ";
    }

    # Have to handle this differently for tar, since we aren't using find in the first place.
    # find everything that _matches_ the regexp, then use it as an exlcude list for tar
    if ($cfg::exclude_expr ne '') {
        push(@cmds,&maybe_remote_cmd("find $dir -xdev -regex \"$cfg::exclude_expr\" -printf \"%P\\n\" > $tmpexclude"));
        $exclude_flag = "-X $tmpexclude ";
    }

    $archive_cmd  = "tar -c ";
    $archive_cmd .= "-C $dir ";
    $archive_cmd .= "-l ";
    $archive_cmd .= $date_flag;
    $archive_cmd .= $exclude_flag;
    $archive_cmd .= "-p ";
    $archive_cmd .= "-s ";
    $archive_cmd .= "--totals ";
    $archive_cmd .= "-M ";
    $archive_cmd .= "-b $main::tar_blksize ";
    $archive_cmd .= "-V \"$title\" ";
    $archive_cmd .= "$main::tar_verb_flag ";
    $archive_cmd .= "-f - . | $main::z";
    if ($main::remote) {
        $archive_cmd .= "$main::buffer_cmd | ";
    }
    $archive_cmd .= &maybe_remote_cmd("$main::buffer_cmd $main::buffer_flags -o $main::device",'"',$main::tapehost);

    push(@cmds,&maybe_remote_cmd($archive_cmd));

    if ($cfg::exclude_expr ne '') {
        push(@cmds,&maybe_remote_cmd("rm -f $tmpexclude"));
    }

    return(@cmds);

}

######################################################################
# List the files in an archive
######################################################################
sub list_routine {

    my $cmd = &setup_before_read();

    if ($cfg::type eq 'dump') {
	$cmd .= "restore -t -b $cfg::blksize -f -";

    } elsif ($cfg::type eq 'afio') {
        $cmd .= "afio -t -s 0 -z -D $main::path_to_echo $main::afio_verb_flag -b $main::afio_blksize $main::afio_bnum_flag -";

    } elsif ($cfg::type eq 'tar') {
        $cmd .= "tar -t -M --totals $main::tar_verb_flag -b $main::tar_blksize -f -";

    } elsif ($cfg::type eq 'cpio') {
        if ($main::device =~ m/\.rpm$/) {
            $cmd .= "rpm2cpio | ";
        }
        $cmd .= "cpio -t $main::cpio_verb_flag -C $main::cpio_blksize";

    }

    &run_or_echo_then_query_and_exit($cmd);

}

######################################################################
# Extract an archive to current directory
######################################################################
sub extract_routine {

    my $cmd = &setup_before_read();

    if ($cfg::type eq 'dump') {
	$cmd .= "restore -r -v -b $cfg::blksize -f -";

    } elsif ($cfg::type eq 'afio') {
        $cmd .= "afio -i -s 0 -z -x -D $main::path_to_echo $main::afio_unz_flag $main::afio_verb_flag $main::afio_bnum_flag -b $main::afio_blksize - ";

    } elsif ($cfg::type eq 'tar') {
        $cmd .= "tar -x -M --totals -p -s $main::tar_verb_flag -b $main::tar_blksize -f -";

    } elsif ($cfg::type eq 'cpio') {
        if ($main::device =~ m/\.rpm$/) {
            $cmd .= "rpm2cpio | ";
        }
        $cmd .= "cpio -i -m -d $main::cpio_verb_flag -C $main::cpio_blksize";
    }

    &run_or_echo_then_query_and_exit($cmd);

}

######################################################################
# Compare an archive to current directory
######################################################################
sub compare_routine {

    my $cmd = &setup_before_read();

    if ($cfg::type eq 'dump') {
	$cmd .= "restore -C -b $cfg::blksize -f -";

    } elsif ($cfg::type eq 'afio') {
        $cmd .= "afio -r -s 0 -z -D $main::path_to_echo $main::afio_unz_flag -b $main::afio_blksize -";

    } elsif ($cfg::type eq 'tar') {
        $cmd .= "tar -d -M --totals -b $main::tar_blksize -f -";

    } elsif ($cfg::type eq 'cpio') {
        die("cpio not capable of comparing files");

    }

    &run_or_echo_then_query_and_exit($cmd);

}

######################################################################
# Interactive restore
######################################################################
sub restore_routine {

    my $cmd = &setup_before_read();

    if ($cfg::type eq 'dump') {
	$cmd .= "restore -i -v -b $cfg::blksize -f -";

    } else {
        die("Interactive restore for $cfg::type not implemented yet");
    }

    &run_or_echo_then_query_and_exit($cmd);

}

######################################################################
# Return the "label" name of the filesystem/dir
######################################################################
sub get_label {

    my $path = shift(@_);
    my $host = '';
    my $label;

    if ($path =~ m/(\S+):(\S+)/) {
        $host = $1 . "-";
        $label = $2;
    } else {
        $label = $path;
    }

    $label =~ s%^/%%; # nuke leading slash
    $label =~ s%/%-%g; # turn / into -
    $label = 'root' if ($label eq '');

    return($host . $label);

}

######################################################################
# Return a date string of the timestamp file
# from the last dump of this level or lower
######################################################################
sub get_last_date {

    my $label = shift(@_);
    my $readable = shift(@_);
    my $file;
    my $val;
    my $val_readable;
    my $print_val;
    my $lastlevel = 0;
    my $targetfile = '';

    # Find last stamp file
    opendir(DIR,"$cfg::stampdir") or die("Can't open $cfg::stampdir: $OS_ERROR");
    my @files = readdir(DIR);
    foreach $file (reverse sort @files) {
        next if ($file !~ m/^$cfg::sprefix$label\.([0-9])$/);
        if ($1 <= $main::level) {
            $targetfile = "$cfg::stampdir/$file";
            $lastlevel = $1;
            last;
        }
    }
    close(DIR);

    # get date from targetfile
    # or complain if level > 0 and no timestamp
    # or use the epoch for level 0
    if ($main::level eq "0") {
        $val = '197001010000.00';
        $print_val = "the epoch";

    } elsif ($targetfile ne '') {
        chomp($val_readable = `date -r $targetfile`);
        chomp($_ = `date -r $targetfile +%Y%m%d%H%M.%S`);
        $val = $_;
        $print_val = $_;

    } else {
        die("Can't do a level $main::level backup - no level 0 timestamp found");

    }

    &log("| Date of last level $lastlevel backup: $print_val");
    &log("| Date of this level $main::level backup: $main::date_at_start");
    &line();

    if (defined($readable)) {
        return($val_readable);
    } else {
        return($val);
    }
}

######################################################################
# Echo message to screen and log
######################################################################
sub log {

    my $msg = shift(@_);

    print "$msg\n";
    if (defined($main::log)) {
        open(LOG,">>$main::log");
        print LOG "$msg\n";
        close(LOG);
    }

}

######################################################################
# Echo a line to both screen and log
######################################################################
sub line {

    my $logonly = shift(@_);

    if (!defined($logonly)) {
        print "|-------------------------------------------\n";
    }
    if (defined($main::log)) {
        open(LOG,">>$main::log");
        print LOG "|-------------------------------------------\n";
        close(LOG);
    }

}

######################################################################
# Read configuration file
######################################################################
sub readconfigfile {

    my $configfile;
    my $var;
    my $value;
    my $defines = $main::opt{'d'};

    if (defined($main::opt{'c'})) {
        $configfile = $main::opt{'c'};
    } else {
        $configfile = "/etc/flexbackup.conf";
    }
    if (! -r $configfile) {
        die("config file $configfile: $OS_ERROR");
    }
    system("perl -c $configfile 2>&1");
    if ($CHILD_ERROR) {
        die("syntax error in config file $configfile");
    }

    package cfg;
    require "$configfile";
    package main;

    # Overrides
    foreach $var (keys %$defines) {
        $value = $$defines{$var};
        &log("(override) $var = $value");
        eval("\$cfg::$var=\"$value\"");
    }

}

######################################################################
# Do a tape operation
######################################################################
sub mt {

    my (@operations) = (@_);
    my $operation;
    my $oldoperation;
    my $out;

    # Set hardware compression when we do the blocksize
    # Can someone who has a drive that does this tell me if this works???
    if ($cfg::compress eq "hardware") {
        foreach (@operations) {
            if ($_ =~ m/generic-blksize/) {
                push(@operations,'compression 1');
            }
        }
    }

    foreach $operation (@operations) {
        # mt & ftmt slightly different
        if ($operation eq 'generic-query') {
            if ($cfg::ftape eq 'true') {
                $operation = 'getsize';
            } else {
                $operation = 'status';
            }
        }

        # mt & ftmt slightly different
        if ($operation eq 'generic-eod') {
            if ($cfg::ftape eq 'true') {
                $operation = 'eom';
            } else {
                $operation = 'eod';
            }
        }

        if (defined($main::use_file)) {
            if (defined($main::opt{'fs'})) {
                &log("| Archiving to file; \"mt $operation\" skipped");
            } else {
                &log("| Reading from file; \"mt $operation\" skipped");
            }
        } elsif (defined($main::opt{'n'})) {
            &log("| (debug) $main::mt -f $main::device $operation");

        } else {

            if ($operation =~ m/(generic-blksize)/) {

                # BSD mt is slightly different
                if ($main::uname =~ /BSD/) {
                    $operation =~ s/generic-blksize/blocksize/;
                } else {
                    $operation =~ s/generic-blksize/setblk/;
                    # Try and see which of setblk/defblksize will work
                    # This is kludgy, but doable
                    chomp($out = `$main::mt -f $main::device $operation 2>&1`);
                    if ($CHILD_ERROR) {
                        &log("| Trying \"mt defblksize\" instead of \"mt setblk\"");
                        $oldoperation = $operation;
                        $operation =~ s/setblk/defblksize/;
                        chomp($out = `$main::mt -f $main::device $operation 2>&1`);
                        if ($CHILD_ERROR) {
                            &log("Error setting block size");
                            &log("Neither of these commands worked:");
                            &log("  $main::mt -f $main::device $oldoperation");
                            &log("  $main::mt -f $main::device $operation");
                            exit(1);

                        } # error on second guess
                    } # error on first guess
                } # not BSD
            } # if generic-blksize

            if (defined($main::log)) {
                system("$main::mt -f $main::device $operation 2>&1 | tee -a $main::log");
            } else {
                system("$main::mt -f $main::device $operation 2>&1");
            }

            if ($CHILD_ERROR) {
                &log("Error from $main::mt $operation\n");
                exit(1);
            }

        } # not a file

    } # foreach operation

}

######################################################################
# Option error checking
######################################################################
sub optioncheck {

    # archive type on commandline
    if (defined($main::opt{'type'})) {
        $cfg::type = $main::opt{'type'};
    }

    # First check if things are defined in the config file
    # Checks exist, true/false, or one of options
    &check(\$cfg::type,'type','dump afio tar cpio');
    &check(\$cfg::compress,'compress','gzip bzip2 false hardware');
    &check(\$cfg::compr_level,'compr_level','exist');
    &check(\$cfg::verbose,'verbose');
    &check(\$cfg::buffer_megs,'buffer_megs','exist');
    &check(\$cfg::device,'device','exist');
    &check(\$cfg::blksize,'blksize','exist');
    &check(\$cfg::remoteshell,'remoteshell','ssh ssh2 ssh1 rsh');
    &check(\$cfg::logdir,'logdir','exist');
    &check(\$cfg::comp_log,'comp_log','gzip bzip2 false');
    &check(\$cfg::stampdir,'stampdir','exist');
    &check(\$cfg::prefix,'prefix','exist');
    &check(\$cfg::sprefix,'sprefix','exist');
    &check(\$cfg::exclude_expr,'exclude_expr','exist');
    &check(\$cfg::afio_echo_block,'afio_echo_block');
    &check(\$cfg::afio_nocompress_types,'afio_nocompress_types','exist');
    &check(\$cfg::afio_compress_threshold,'afio_compress_threshold','exist');
    &check(\$cfg::dump_length,'dump_length','exist');
    &check(\$cfg::cpio_format,'cpio_format','bin odc newc crc tar ustar hpbin hpodc');
    &check(\$cfg::ftape,'ftape');
    &check(\$cfg::rawdevice,'rawdevice','exist');
    if (@main::errors) {
        print "\nErrors:\n";
        while(@main::errors) {
            print " " . pop(@main::errors) . "\n";
        }
        exit(1);
    }

    # check device (or dir)
    if (-c $cfg::device) {
        # ok
    } elsif (-d $cfg::device) {
        if ($cfg::device !~ m:^/:) {
            push(@main::errors,"Please give full path, not relative (\$device=$cfg::device)");
        } else {
            $main::use_file = 1;
            $cfg::device =~ s:/$::; # nuke trailing slash if any
        }
    } else {
        push(@main::errors,"\$device must be set to a directory or a device");
    }
    $main::device = $cfg::device;

    # can we write to it?
    if (! -w $main::device) {
        push(@main::errors,"Can't write to $main::device");
    }

    # exclude regexp for find
    if ($cfg::exclude_expr ne '') {
        $main::exclude_flag = '-not -regex "' . $cfg::exclude_expr . '" ';
    } else {
        $main::exclude_flag = '';
    }

    # generic compression (afio will do its own flags)
    if ($cfg::compress =~ m/^(gzip|bzip2)$/) {
        &checkinpath($cfg::compress);
        if ($cfg::compr_level !~ m/^[123456789]$/) {
            push(@main::errors,"\$compr_level must be set to 1-9");
        } else {
            $main::z = "$cfg::compress -$cfg::compr_level | ";
        }
        $main::unz = "$cfg::compress -dq";
    } else {
        $main::z = '';
        $main::unz = 'cat';
    }

    # buffer stuff
    $main::buffer_blksize = $cfg::blksize . "k";
    &checkinpath('buffer');
    if ($cfg::buffer_megs =~ m/^\d+$/) {
        $main::buffer_megs = $cfg::buffer_megs . "m";
        $main::buffer_cmd = "buffer -m $main::buffer_megs -s $main::buffer_blksize";
        $main::buffer_flags = "-t -p 75 -B -u 100";
    } else {
        push(@main::errors,"\$buffer_megs must be set to integer number of megabytes");
    }

    # check we can find rsh or ssh
    &checkinpath($cfg::remoteshell);

    # check we can find common stuff
    &checkinpath('touch');
    &checkinpath('date');
    &checkinpath('hostname');
    &checkinpath('tee');
    &checkinpath('rm');
    &checkinpath('find');

    # Use this to "cheat" afio control scripts into being volume labels
    $main::path_to_echo = &checkinpath('echo');

    # ftape support
    if ($cfg::ftape eq 'true') {
        &checkinpath('ftmt');
        &checkinpath('vtblc');
        $main::mt = 'ftmt';
    } else {
        &checkinpath('mt');
        $main::mt = 'mt';
    }

    # blksize
    if ($cfg::blksize !~ m/^\d+$/) {
        push(@main::errors,"\$blksize must be set to an integer");
    } else {
        if ($cfg::blksize < 10) {
            push(@main::errors,"\$blksize minimum is 10k");
        }
    }

    # mt uses blocksize of bytes not k
    $main::mt_blksize = $cfg::blksize * 1024;

    # filesystems
    $main::num_tapes = -1;
    foreach (@cfg::filesystems) {
        $main::num_tapes++;
    }
    if ($main::num_tapes == -1) {
        push(@main::errors,"no filesystem spec for \"all\" backups");
    }

    # Type-specific setup
    if ($cfg::type eq 'afio') {

        &checkinpath('afio');

        # Compress flag
        if ($cfg::compress =~ m/^(gzip|bzip2)$/) {
            $main::afio_z_flag = "-P $cfg::compress -Q -$cfg::compr_level -Z";
            $main::afio_unz_flag = "-P $cfg::compress -Q -d -Q -q -Z";
            $main::unz = "cat"; # fix this up for reading

            # Compression threshold
            if ($cfg::afio_compress_threshold !~ m/^\d+$/) {
                push(@main::errors,"\$afio_compress_threshold must be set to an integer");
            } else {
                if ($cfg::afio_compress_threshold != 0) {
                    $main::afio_z_flag .= " -T " . $cfg::afio_compress_threshold . "k";
                }
            }
        } else {
            $main::afio_z_flag = "";
            $main::afio_unz_flag = "";
        }

        # Verbose flag
        if ($cfg::verbose eq "true") {
            $main::afio_verb_flag = "-v";
        } else {
            $main::afio_verb_flag = "";
        }

        # echo block number
        if ($cfg::afio_echo_block eq "true") {
            $main::afio_bnum_flag = "-B";
        } else {
            $main::afio_bnum_flag = "";
        }

        # For afio, blocksize needs k appended
        $main::afio_blksize = $cfg::blksize . "k";

    } elsif ($cfg::type eq 'dump') {

        &checkinpath('dump');
        &checkinpath('restore');

        # Length of tape
        if ($cfg::dump_length =~ m/^\d+$/) {
            # Really need buffer in units of blksize not k
            # Huh? this seems to be bogus, B flag is always
            # taken in k. Is the man page for dump wrong?
            #if (($cfg::dump_length % $cfg::blksize) != 0) {
            #    push(@main::errors,"\$dump_length must be multiple of \$blksize\n");
            #}
            #$cfg::dump_length = $cfg::dump_length / $cfg::blksize;
        } else {
            push(@main::errors,"\$dump_length must be set to integer number of kilobytes");
        }

        # If length set to 0 will will try autosize
        if ($cfg::dump_length eq "0") {
            $main::dump_len_flag = "-a";
        } else {
            $main::dump_len_flag = "-B $cfg::dump_length";
        }

    } elsif ($cfg::type eq 'tar') {

        &checkinpath('tar');

        # Verbose flag
        if ($cfg::verbose eq "true") {
            $main::tar_verb_flag = "-v";
        } else {
            $main::tar_verb_flag = "";
        }

        # For tar, blocks are in 512-byte units
        # not 1024 (1k) like dump, afio
        $main::tar_blksize = $cfg::blksize * 2;

    } elsif ($cfg::type eq 'cpio') {

        &checkinpath('cpio');

        # Verbose flag
        if ($cfg::verbose eq "true") {
            $main::cpio_verb_flag = "-v";
        } else {
            $main::cpio_verb_flag = "-V";
        }

        # For cpio, blocks are in bytes
        # not 1024 (1k) like dump, afio
        $main::cpio_blksize = $cfg::blksize * 1024;
    }

    # log/stamp files
    &checkinpath($cfg::comp_log) if ($cfg::comp_log ne "false");

    if ($cfg::logdir !~ m:^/:) {
        push(@main::errors,"\$logdir must be absolute path: $cfg::logdir");
    }
    if ($cfg::stampdir !~ m:^/:) {
        push(@main::errors,"\$stampdir must be absolute path: $cfg::stampdir");
    }
    if (! -d $cfg::logdir) {
        mkdir("$cfg::logdir",0755) or push(@main::errors,"Can't mkdir $cfg::logdir: $OS_ERROR");
    }
    if (! -w $cfg::logdir) {
        push(@main::errors,"Can't write to $cfg::logdir: $OS_ERROR");
    }
    if (! -d $cfg::stampdir) {
        mkdir("$cfg::stampdir",0755) or push(@main::errors,"Can't mkdir $cfg::stampdir: $OS_ERROR");
    }
    if (! -w $cfg::stampdir) {
        push(@main::errors,"Can't write to $cfg::stampdir: $OS_ERROR");
    }

    # levels
    if (defined($main::opt{'level'})) {
        if ($main::opt{'level'} !~ m/^\d$/) {
            push(@main::errors,"-level must be 0 through 9 only");
        }
    }

    # mode
    my (@modelist) = qw(fs list extract compare restore toc);
    my @modes;
    my $modecount = 0;
    foreach (@modelist) {
        if (defined($main::opt{$_})) {
            $modecount++;
            push(@modes,$_);
        }
    }
    if ($modecount > 1) {
        $_ = join(" -",@modes);
        push(@main::errors,"Can't specify more than one mode (given \"-$_\")");
    }
    if ($modecount == 0) {
        push(@main::errors,"Nothing to do (see -help)");
    }

    # test
    if (defined($main::opt{'n'})) {
        &log('(debug) no backup or mt commands will be executed');
    }


    if (@main::errors) {
        print "\nErrors:\n";
        while(@main::errors) {
            print " " . pop(@main::errors) . "\n";
        }
        exit(1);
    }

}

######################################################################
# Print usage summary from the header
######################################################################
sub usage {

    open(FILE,"$0") or die "Can't open $0: $OS_ERROR";
    while(<FILE>) {
        last if (m/^\#\s+USAGE:/);
    }
    while(<FILE>) {
        last if (m/^\#\#\#\#\#\#\#/);
        s/^\#//;
        print;
    }
    close(FILE);

}

######################################################################
# Return version string from CVS tag
######################################################################
sub versionstring {

    my $ver = ' $Name$ ';
    $ver =~ s/Name//g;
    $ver =~ s/[:\$]//g;
    $ver =~ s/\s+//g;
    $ver =~ s/^v//g;
    $ver =~ s/_/\./g;
    if ($ver eq '') {
        $ver = "devel";
    }
    return($ver . " <edwinh+flexbackup\@computer.org>");

}

######################################################################
# Return current time in YYYYMMDDHHMM.SS format
######################################################################
sub current_time {

    my $short = shift(@_);
    my $string;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);

    $year += 1900;              # year from localtime has 1900 subtracted
    $mon += 1;                  # month from localtime starts at 0

    $string = sprintf("%04d",$year) . sprintf("%02d",$mon) . sprintf("%02d",$mday);

    if (!defined($short)) {
        $string .= sprintf("%02d",$hour) . sprintf("%02d",$min) . "." . sprintf("%02d",$sec);
    }

    return($string);

}

######################################################################
# Possibly return a filename to use
# if running list/extract/compare/restore
######################################################################
sub maybe_get_filename {

    my @modes = qw(list extract compare restore);
    my $arg;
    my $file;
    my $ftype;

    # optionscheck already guarantees only one is set
    foreach (@modes) {
        if (defined($main::opt{$_})) {
            $arg = $main::opt{$_};
        }
    }

    # if the flag given but null , and $device was not set to a dir, just return
    if (($arg eq '') and (!defined($main::use_file))) {
        return($main::device);
    }

    # Look for file in current dir first (or full path given)
    # Then in $device dir (if conf file set to backup to files)
    if (-f "$arg") {
        $file = $arg;
        $main::use_file = 1;

    } elsif (defined($main::use_file) and (-f "$cfg::device/$arg")) {
        $file = $cfg::device . "/" . $arg;

    } else {
        if (defined($main::use_file)) {
            die("Error: file \"$arg\" or \"$cfg::device/$arg\" not found");
        } else {
            die("Error: file \"$arg\" not found");
        }
    }

    # Try and guess file types and commpression scheme
    # might as well since we are reading form a file in this case
    if ($file =~ m/\.(dump|cpio|tar)\.(gz|bz2)$/) {
        $cfg::type = $1;
        $cfg::compress = $2;
        $cfg::compress =~ s/gz/gzip/;
        $cfg::compress =~ s/bz2/bzip2/;
        &line();
        &log("| Auto-set to type=$cfg::type compress=$cfg::compress");
        &optioncheck(); # redo to set a few variables over

    } elsif ($file =~ m/\.(dump|cpio|tar)$/) {
        $cfg::type = $1;
        $cfg::compress = "false";
        &line();
        &log("| Auto-set to type=$cfg::type compress=$cfg::compress");
        &optioncheck(); # redo to set a few variables over

    } elsif ($file =~ m/\.afio-(gz|bz2)$/) {
        $cfg::type = "afio";
        $cfg::compress = $1;
        $cfg::compress =~ s/gz/gzip/;
        $cfg::compress =~ s/bz2/bzip2/;
        &line();
        &log("| Auto-set to type=$cfg::type compress=$cfg::compress");
        &optioncheck(); # redo to set a few variables over

    } elsif ($file =~ m/\.afio$/) {
        $cfg::type = "afio";
        $cfg::compress = "false";
        &line();
        &log("| Auto-set to type=$cfg::type compress=$cfg::compress");
        &optioncheck(); # redo to set a few variables over

    } elsif ($file =~ m/\.tgz$/) {
        $cfg::type = "tar";
        $cfg::compress = "gzip";
        &line();
        &log("| Auto-set to type=$cfg::type compress=$cfg::compress");
        &optioncheck(); # redo to set a few variables over

    } elsif ($file =~ m/\.rpm$/) {
        $cfg::type = "cpio";
        $cfg::compress = "false";
        &line();
        &log("| Auto-set to type=$cfg::type compress=$cfg::compress");

    }

    return($file);

}

######################################################################
# Update table of contents
######################################################################
sub update_toc {

    # Only ftape has the toc capability
    if ($cfg::ftape eq 'true') {
        &log('| Updating table of contents...');
        foreach (keys %main::title) {
            &tag($_,$main::title{$_});
        }
    }
}

######################################################################
# Check validity of a config option
######################################################################
sub check {

    my $ref = shift(@_);
    my $varname = shift(@_);
    my $ok = shift(@_);         # list of ok values, or empty for t/f, or "exists"
    my @ok;
    my $found = 0;
    my $realvarname;

    if (!defined($ok)) {
        @ok = ('true','false');
    } else {
        @ok = split(" ",$ok);
    }

    if (!defined($$ref)) {
        push(@main::errors,"\$$varname not defined");
    } else {
        if ($ok[0] ne "exist") {
            foreach (@ok) {
                if ($_ eq $$ref) {
                    $found = 1;
                }
            }
            if ($found == 0 ) {
                $_ = join(", ",@ok);
                push(@main::errors,"\$$varname must be one of $_");
            }
        }
    }

}

######################################################################
# Check to see if a program is found in $PATH
######################################################################
sub checkinpath {
    my ($file) = @_;
    my ($dir, @path);

    @path = split(/:/,$ENV{'PATH'});

    foreach $dir (@path) {
        if (-e "${dir}/$file" && -x _) {
            return "${dir}/$file";
        }
    }
    push(@main::errors,"$file not found in \$PATH");
    return(0);

}

######################################################################
# Run  a command, or echo it depending on the -n flag
# Then show tape drive position and exit
######################################################################
sub run_or_echo_then_query_and_exit {

    my $cmd = shift(@_);

    if (!defined($main::opt{'n'})) {
        system($cmd);
    } else {
        &log("$cmd");
    }

    &line();
    &mt('generic-query');
    &line();
    exit(0);

}

######################################################################
# Return a command possibly wrapped in ssh/rsh
######################################################################
sub maybe_remote_cmd {

    my $cmd = shift(@_);
    my $quote = shift(@_);
    my $machine = shift(@_);

    if (!defined($machine)) {
        $machine = $main::remote;
    }

    if (!defined($quote)) {
        $quote = "'";
    }

    if ($main::remote) {
	$cmd  = "$cfg::remoteshell $machine " . $quote . $cmd . $quote;
    }

    return($cmd);

}

######################################################################
# Stuff to do before list/restore/extract/compare
# return command to get archive on stdout
######################################################################
sub setup_before_read {

    $main::device = &maybe_get_filename();

    &line();
    &mt("generic-blksize $main::mt_blksize");
    if (defined($main::opt{'reten'})) {
        &mt("retension");
        &line();
    }
    &mt('generic-query');
    &line();

    return("$main::unz < $main::device | ");

}


######################################################################
# Get rid of trailing slash on path or host:/path specs
######################################################################
sub nuke_trailing_slash {

    my $spec = shift(@_);
    my $host;
    my $path;

    if ($spec =~ m/(\S+:)(\S+)/) {
        $host = $1;
        $path = $2;
    } else {
        $host = '';
        $path = $spec;
    }

    if ($path ne "/") {
        $path =~ s%/$%%;
    }

    return($host . $path);

}
