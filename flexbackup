#!/usr/bin/perl -w
######################################################################
#
# Edwin Huffstutler, <edwinh@computer.org>
# $Id$
# $Name$
#
#         >>>> See the README file <<<<
#
# USAGE:
#
#  flexbackup -help                : this message
#
#  flexbackup -fs all              : backup all filesystems, level 0
#  flexbackup -fs <x>              : backup filesystem <x>, level 0
#  flexbackup -fs all -level <n>   : backup all filesystems, level n
#  flexbackup -fs <x> -level <n>   : backup filesystem <x>, level n
#
#  flexbackup -list                : list files in archive at current
#                                    tape position
#
#  flexbackup -extract             : restore from current tape position
#                                    into your current working directory
#
#  flexbackup -compare             : compare archive at current tape position
#                                    with the files in your current directory
#
#  flexbackup -restore             : as above, but interactive restore
#                                    (dump type only for now)
#
#  flexbackup -<operation> file    : if archiving to files rather than a device,
#                                    list/extract/compare/restore options take
#                                    a filename argument
#
#  flexbackup -toc                 : list tape table of contents
#                                    with Linux ftape only
#
#  flexbackup [opt] -c <file>      : use <file> instead of /etc/flexbackup.conf
#                                    for configuration
#
#  flexbackup [opt] -type <x>      : override $type from config file
#
#  flexbackup -fs <x> -erase       : force a rewind/erase before backup
#  flexbackup -fs all -noreten     : don't retension for level 0 "all" backups
#  flexbackup -fs all -noerase     : don't rewind/erase for level 0 "all" backups
#
#  flexbackup [opt] -n             : don't run actual dump or mt commands
#  flexbackup [opt] -d 'var=val'   : override config file setting of $var
#  flexbackup -version             : show version
#
######################################################################

use Getopt::Long;
use English;
use strict;

# No output buffering
$OUTPUT_AUTOFLUSH = 1;

package global;

%global::opt = ();
if (! &main::GetOptions(\%global::opt,
                        "help",
                        "c=s",
                        "level=i",
                        "fs=s",
                        "extract:s",
                        "restore:s",
                        "list:s",
                        "compare:s",
                        "toc",
                        "type=s",
                        "noreten",
                        "noerase",
                        "erase",
                        "version",
                        "n",
                        "d=s%"
		  )) {
    &usage();
    exit(0);
}

# Give usage message
if (defined($global::opt{'help'})) {
    &usage();
    exit(0);
}

# Version
if (defined($global::opt{'version'})) {
    print ('$Id$ ');
    print "\nflexbackup version " . &versionstring();
    exit(0);
}


# Get/read config file
&readconfigfile();

# Set OS type
chomp($global::uname = `uname -s`);

# Sanity check things
&optioncheck();

# Get current date string (YYYYMMDD only)
@_ = localtime(time);
$_[5] += 1900;
$_[4] += 1;
$global::date = $_[5] . sprintf("%02d",$_[4]) . sprintf("%02d",$_[3]);

# Set blocksize (mt blocksize is in bytes, config file is in k
$_ = $cfg::blksize * 1024;
&mt("generic-blksize $_");

# Decide what to do
if (defined($global::opt{'restore'})) {
    &restore_routine();

} elsif (defined($global::opt{'extract'})) {
    &extract_routine();

} elsif (defined($global::opt{'compare'})) {
    &compare_routine();

} elsif (defined($global::opt{'list'})) {
    &list_routine();

} elsif (defined($global::opt{'fs'})) {
    &backup_routine();

} elsif (defined($global::opt{'toc'})) {

    if ($cfg::ftape eq 'true') {
	&mt('rewind');
	exec("vtblc -p -f $cfg::rawdevice");
	die("Failed exec of vtblc\n");
    } else {
	die("-toc only implemented for ftape under Linux\n");
    }

}

exit(0);

######################################################################
# Backup
######################################################################
sub backup_routine {

    my @files;
    my $label;
    my $list;
    my $tapecounter = 1;

    # Get backup level...
    if (defined($global::opt{'level'})) {
        $global::level = $global::opt{'level'};
    } else {
        $global::level = 0;
    }

    # Die if no fs specified
    if (!defined($global::opt{'fs'})) {
        &usage();
        exit(0);
    }

    # Figure out log file name & empty log file
    $label = &get_label($global::opt{'fs'});
    $global::log = "$cfg::logdir/$cfg::prefix$label.$global::level.$global::date";
    if (! open(LOG,">$global::log")) {
        die "Can't write to $global::log: $!\n";
    }
    close(LOG);

    # Spew some info
    &log("flexbackup version " . &versionstring());
    $_ = &current_time();
    &log("Current time is $_");
    &log("Doing level $global::level backup of $global::opt{fs} using $cfg::type");

    # Remove old log files
    # ("old" = any higher-numbered logs for this label)
    opendir(DIR,"$cfg::logdir") or die("Can't open cfg::logdir: $!\n");
    @files = readdir(DIR);
    foreach (reverse sort @files) {
        next if (! m/^$cfg::prefix$label\.([0-9])\.([0-9]+)(.gz)?$/);
        my $olddate = $2;
        if ($1 > $global::level) {
            print "Removing old level $1 log of $global::opt{fs} ($olddate)\n";
            unlink("$cfg::logdir/$_") or warn("Can't remove $_: $!\n");
        }
    }
    close(DIR);

    # Remove old stamp files
    # ("old" = any higher-numbered stamps for this label)
    opendir(DIR,"$cfg::stampdir") or die("Can't open $cfg::stampdir: $!\n");
    @files = readdir(DIR);
    foreach (reverse sort @files) {
        next if (! m/^$cfg::sprefix$label\.([0-9])$/);
        if ($1 > $global::level) {
            print "Removing old level $1 timestamp of $global::opt{fs}\n";
            unlink("$cfg::stampdir/$_") or warn("Can't remove $_: $!\n");
        }
    }
    close(DIR);


    ##########################
    #
    # Main backup routine
    #
    ##########################
    if ($global::opt{'fs'} eq 'all') {

        foreach $list (@cfg::filesystems) {

            &line();

            if ($global::level eq "0") {

                &log("Tape \#$tapecounter filesystems = $list");

                # All
                # Level zero - rewind and erase a new tape
                if (!defined($global::opt{'noreten'})) {
                    &log('Retensioning tape...');
                    &mt('retension');
                }
                if (!defined($global::opt{'noerase'})) {
                    &log('Rewinding & erasing tape...');
                    &mt('rewind');
                    &mt('erase');
                    $global::nextfile = 0;
                }

            } else {

                &log("Filesystems = $list");

                # All
                # Incremental backup - list what's on it, then go to end of tape
                if (!defined($global::opt{'erase'})) {
                    $global::nextfile = &contents();
                    &log('Making sure tape is at end of data...');
                    &mt('generic-eod');
                } else {
                    $global::nextfile = 0;
                    &log('Rewinding & erasing tape...');
                    &mt('rewind');
                    &mt('erase');
                }
            }

            # Show tape position
            &line();
            &mt('generic-query');

            # Iterate over the filesystems and back 'em up
            foreach (split(/\s+/,$list)) {
                &backup($cfg::type,$_);
                $global::contents{$global::nextfile} = "$cfg::type $_ ($global::level)";
                $global::nextfile++;
            }

            # Prompt for new tape if more than one set in list & level 0
            if ($global::level == 0) {
                if ($tapecounter < $global::num_tapes) {

                    # Rewind
                    &line();
                    &log("Rewinding...");
                    &mt('rewind');

                    &update_toc();

                    $tapecounter++;
                    print "\n---> Insert tape \#$tapecounter\n";
                    $_ = <STDIN>;
               }
            }
        }

        # Rewind
        &line();
        &log("Rewinding...");
        &mt('rewind');

        &update_toc();

    } else {

        # Just one filesystem
	&line();
        if (!defined($global::opt{'erase'})) {
            $global::nextfile = &contents();
            &log('Making sure tape is at end of data...');
            &mt('generic-eod');
        } else {
            $global::nextfile = 0;
            &log('Rewinding & erasing tape...');
            &mt('rewind');
            &mt('erase');
        }
        &line();
        &mt('generic-query');
        &backup($cfg::type,$global::opt{'fs'});
        &line();
        &log("Rewinding...");
        &mt('rewind');
        if ($cfg::ftape eq 'true') {
            &log('Updating table of contents...');
            &tag($global::nextfile,"$cfg::type $global::opt{'fs'} ($global::level)");
        }
    }

    # Print out new contents
    &contents();

    # gzip log file
    if ($cfg::gzip_log eq 'true') {
        print "Compressing log file ($global::log)\n";
        system("gzip -f $global::log");
        if ($?) {
            warn("error compressing log file\n");
        }
    }

    exit(0);

}

######################################################################
# Rewind & print TOC using vtblc
# returns an integer that is the next file number
######################################################################
sub contents {

    my $output;
    my $filenumber;

    if ($cfg::ftape eq "true") {
        &mt('rewind');
        &log('');
        $output=`vtblc -p -f $cfg::rawdevice 2>&1`;
        &log($output);
        &log('');
        $filenumber = -1;
        foreach (split("\n",$output)) {
            # Nr  Id          Label
            #-------------------------------
            #  0 VTBL "/var (level 9)
            next if m/^\s+Nr\s+/;
            next if m/^----------/;
            if (m/^\s+(\d+)\s+\S+\s+\"/) {
                $filenumber = $1;
            }
        }

    } else {

        $filenumber = 0;
    }

    $filenumber++;
    return($filenumber);
}

######################################################################
# Modify a table of contents entry
######################################################################
sub tag {

    my $filenum = shift(@_);
    my $title = shift(@_);

    system("vtblc -f $cfg::rawdevice -# $filenum -m date -m label=\'$title\'");

}

######################################################################
# Backup a filesystem
######################################################################
sub backup {

    my $type = shift(@_);
    my $dir = shift(@_);
    my $cmd;
    my $tapehost;
    my $remote;
    my $date_at_start;
    my $localdir = $dir;
    my $label = &get_label($dir);

    if ($localdir =~ s/^(.+):(.+)$/$2/) {
	$remote = $1;
	chomp($tapehost = `hostname`);
    } else {
        $remote = '';
    }

    # Create file name if writing to a file
    # (config file's $device points to a dir in this case)
    if (defined($global::use_file)) {
        $_ = $global::date . "." . $type;
        if (($type eq "tar") and ($cfg::tar_compress ne '')) {
            $_ .= ".gz";
        }
        $cfg::device = $cfg::device . "/" . $label . "." . $_;
    }

    if ($type eq 'dump') {
	$cmd = &backup_dump($label,$localdir,$remote,$tapehost);
    } elsif ($type eq 'afio') {
	$cmd = &backup_afio($label,$localdir,$remote,$tapehost);
    } elsif ($type eq 'tar') {
	$cmd = &backup_tar($label,$localdir,$remote,$tapehost);
    } elsif ($type eq 'cpio') {
	$cmd = &backup_cpio($label,$localdir,$remote,$tapehost);
    }

    # If we started with level 0, and "all", and -noerase not given,
    # we know the file number, since we erased the tape
    # (or if using ftape/vtblc, since we can find the file number)
    # (or if we had -erase on the commandline)
    if ((($global::opt{'fs'} eq "all") and ($global::level eq "0") and (!defined($global::opt{'noerase'})))
        or
        ($cfg::ftape eq "true")
        or
        ($global::opt{'erase'})) {
        &log("Backup will be file number $global::nextfile");
    }

    # Just get the date for now; don't write the timestamp
    # Until after the backup has run
    $date_at_start = &current_time();

    # Enough fooling around... run it
    &line();
    &log("$cmd");
    &line();
    if (!defined($global::opt{'n'})) {
        system("($cmd) 2>&1 | tee -a $global::log");
        if ($?) {
            &log("$type: error from backup, exiting....\n");
            exit(1);
        }
    } else {
        &log("(debug) command output would be here");
    }

    # tar is causing me fits; mt right after archive operations is giving i/o errors
    if ($type eq 'tar') {
        sleep 5;
    }

    # Create timestamp file, but use date from before the backup started
    # so next time we will catch files that might have been toucehd during the run
    &line();
    &log("Timestamp $date_at_start $cfg::stampdir/$cfg::sprefix$label.$global::level");
    system("touch -t $date_at_start $cfg::stampdir/$cfg::sprefix$label.$global::level");
    $_ = &current_time();
    &log("Current time is $_");

    # Show where we are on the tape
    &line();
    &mt('generic-query');

}

######################################################################
# Return command to backup a filesystem using dump
######################################################################
sub backup_dump {

    my $label = shift(@_);
    my $dir = shift(@_);
    my $remote = shift(@_);
    my $tapehost = shift(@_);
    my $cmd = '';
    my $tmpstamp;
    my $length = $cfg::dump_length;

    if ($remote) {
        $cmd .= "$cfg::remoteshell $remote -n \'";
    }

    if ($length eq "0") {
        $length = "-a";

    } else {
        $length = "-B $cfg::dump_length";
    }

    if ($cfg::dump_dumpdates eq "true") {

        $cmd .= "dump -$global::level -u $length -b $cfg::blksize";

    } else {

        $tmpstamp = "/tmp/refdate.$label";
        $_ = &get_last_date($label,$global::level);
        $cmd .= "touch -t $_ $tmpstamp && ";

        $cmd .= "dump -$global::level -T $tmpstamp $length -b $cfg::blksize";
    }

    if ($remote) {
        $cmd .= " -f $tapehost:$cfg::device $dir";
    } else {
        $cmd .= " -f $cfg::device $dir";
    }

    if ($cfg::dump_dumpdates eq "false") {
        $cmd .= " && rm -f $tmpstamp";
    }

    if ($remote) {
        $cmd .= "\'";
    }

    return($cmd);

}

######################################################################
# Return command to backup a filesystem using afio
######################################################################
sub backup_afio {

    my $label = shift(@_);
    my $dir = shift(@_);
    my $remote = shift(@_);
    my $tapehost = shift(@_);
    my $cmd = '';
    my $tmpstamp;
    my $double;

    if ($remote) {
	$cmd  .= "$cfg::remoteshell $remote -n \'";
    }

    if ($remote) {
	$double = '';
    } else {
        $double = $cfg::afio_doublebuffer;
    }

    $tmpstamp = "/tmp/refdate.$label";
    $_ = &get_last_date($label,$global::level);
    $cmd .= "touch -t $_ $tmpstamp && ";

    $cmd .= "cd $dir && find . -xdev -newer $tmpstamp -print | ";

    $cmd .= "afio -o -s $cfg::afio_length $cfg::afio_compress $double $cfg::afio_verbose -b $cfg::afio_blksize -c $cfg::afio_buffer";

    if ($remote) {
        $cmd .= " -B $tapehost%$cfg::remoteshell:$cfg::device";
    } else {
        $cmd .= " -B $cfg::device";
    }

    $cmd .= " && rm -f $tmpstamp";

    if ($remote) {
        $cmd .= "\'";
    }

    return($cmd);

}

######################################################################
# Return command to backup a filesystem using cpio
######################################################################
sub backup_cpio {

    my $label = shift(@_);
    my $dir = shift(@_);
    my $remote = shift(@_);
    my $tapehost = shift(@_);
    my $cmd = '';
    my $tmpstamp;

    if ($remote) {
        $cmd .= "$cfg::remoteshell $remote -n \'";
    }

    $tmpstamp = "/tmp/refdate.$label";
    $_ = &get_last_date($label,$global::level);
    $cmd .= "touch -t $_ $tmpstamp && ";

    $cmd .= "cd $dir && find . -xdev -newer $tmpstamp -print | ";

    $cmd .= "cpio -o $cfg::cpio_verbose -H $cfg::cpio_format -C $cfg::cpio_blksize";

    if ($remote) {
        $cmd .= " -F $tapehost:$cfg::device";
    } else {
        $cmd .= " -F $cfg::device";
    }

    $cmd .= " && rm -f $tmpstamp";

    if ($remote) {
        $cmd .= "\'";
    }

    return($cmd);
}

######################################################################
# Return command to backup a filesystem using tar
######################################################################
sub backup_tar {

    my $label = shift(@_);
    my $dir = shift(@_);
    my $remote = shift(@_);
    my $tapehost = shift(@_);
    my $cmd = '';
    my $tmpstamp;

    if ($remote) {
        $cmd .= "$cfg::remoteshell $remote -n \'";
    }

    $tmpstamp = "/tmp/refdate.$label";
    $_ = &get_last_date($label,$global::level);
    $cmd .= "touch -t $_ $tmpstamp && ";

    $cmd .= "cd $dir && find . -xdev -newer $tmpstamp -print | ";

    $cmd .= "tar -c -T - -p -V \"$label\" $cfg::tar_verbose $cfg::tar_compress -b $cfg::tar_blksize";

    if ($remote) {
        $cmd .= " --rsh-command $cfg::remoteshell -f $tapehost:$cfg::device";
    } else {
        $cmd .= " -f $cfg::device";
    }

    $cmd .= " && rm -f $tmpstamp";

    if ($remote) {
        $cmd .= "\'";
    }

    return($cmd);

}

######################################################################
# List the files in an archive
######################################################################
sub list_routine {

    my $cmd;

    &log("flexbackup version " . &versionstring());

    $cfg::device = &maybe_get_filename();

    &line();
    &mt('generic-query');
    &line();

    if ($cfg::type eq 'dump') {
	$cmd = "restore -t -b $cfg::blksize -f $cfg::device";

    } elsif ($cfg::type eq 'afio') {
        $cmd = "afio -t $cfg::afio_verbose -b $cfg::afio_blksize -B $cfg::device";

    } elsif ($cfg::type eq 'tar') {
        $cmd = "tar -t $cfg::tar_verbose $cfg::tar_compress -b $cfg::tar_blksize -f $cfg::device";

    } elsif ($cfg::type eq 'cpio') {
        $cmd = "cpio -t $cfg::cpio_verbose -H $cfg::cpio_format -C $cfg::cpio_blksize -F $cfg::device";

    }

    if (!defined($global::opt{'n'})) {
        system($cmd);
    } else {
        &log("$cmd");
    }

    &line();
    &mt('generic-query');
    exit;

}

######################################################################
# Extract an archive to current directory
######################################################################
sub extract_routine {

    my $cmd;

    &log("flexbackup version " . &versionstring());

    $cfg::device = &maybe_get_filename();

    &line();
    &mt('generic-query');
    &line();

    if ($cfg::type eq 'dump') {
	$cmd = "restore -r -v -b $cfg::blksize -f $cfg::device";

    } elsif ($cfg::type eq 'afio') {
        $cmd = "afio -i -x $cfg::afio_compress $cfg::afio_verbose -b $cfg::afio_blksize -B $cfg::device";

    } elsif ($cfg::type eq 'tar') {
        $cmd = "tar -x -p $cfg::tar_compress $cfg::tar_verbose -b $cfg::tar_blksize -f $cfg::device";

    } elsif ($cfg::type eq 'cpio') {
        $cmd = "cpio -i -m -d $cfg::cpio_verbose -H $cfg::cpio_format -C $cfg::cpio_blksize -F $cfg::device";
    }

    if (!defined($global::opt{'n'})) {
        system($cmd);
    } else {
        &log("$cmd");
    }

    &line();
    &mt('generic-query');
    exit;

}

######################################################################
# Compare an archive to current directory
######################################################################
sub compare_routine {

    my $cmd;

    &log("flexbackup version " . &versionstring());

    $cfg::device = &maybe_get_filename();

    &line();
    &mt('generic-query');
    &line();

    if ($cfg::type eq 'dump') {
	$cmd = "restore -C -b $cfg::blksize -f $cfg::device";

    } elsif ($cfg::type eq 'afio') {
        $cmd = "afio -r $cfg::afio_compress -b $cfg::afio_blksize -B $cfg::device";

    } elsif ($cfg::type eq 'tar') {
        $cmd = "tar -d $cfg::tar_compress -b $cfg::tar_blksize -f $cfg::device";

    } elsif ($cfg::type eq 'cpio') {
        die("cpio not capable of comparing files\n");

    }

    if (!defined($global::opt{'n'})) {
        system($cmd);
    } else {
        &log("$cmd");
    }

    &line();
    &mt('generic-query');
    exit;

}

######################################################################
# Interactive restore
######################################################################
sub restore_routine {

    my $cmd;

    &log("flexbackup version " . &versionstring());

    $cfg::device = &maybe_get_filename();

    &line();
    &mt('generic-query');
    &line();

    if ($cfg::type eq 'dump') {
	$cmd = "restore -i -v -b $cfg::blksize -f $cfg::device";

    } else {
        die("Interactive restore for $cfg::type not implemented yet\n");
    }

    if (!defined($global::opt{'n'})) {
        system($cmd);
    } else {
        &log("$cmd");
    }

    &line();
    &mt('generic-query');
    exit;

}

######################################################################
# Return the "label" name of the filesystem/dir
######################################################################
sub get_label {

    my $path = shift(@_);
    my $host = '';
    my $label;

    if ($path =~ m/(\S+):(\S+)/) {
        $host = $1 . "-";
        $label = $2;
    } else {
        $label = $path;
    }

    $label =~ s%^/%%; # nuke leading slash
    $label =~ s%/%-%g; # turn / into -
    $label = 'root' if ($label eq '');

    return($host . $label);

}

######################################################################
# Return a date string of the timestamp file
# from the last dump of this level or lower
######################################################################
sub get_last_date {

    my $label = shift(@_);
    my $level = shift(@_);
    my $file;
    my $targetfile = '';

    # Find last stamp file
    opendir(DIR,"$cfg::stampdir") or die("Can't open $cfg::stampdir: $!\n");
    my @files = readdir(DIR);
    foreach $file (reverse sort @files) {
        next if ($file !~ m/^$cfg::sprefix$label\.([0-9])$/);
        if ($1 < $global::level) {
            $targetfile = "$cfg::stampdir/$file";
            last;
        }
    }
    close(DIR);

    # get date from targetfile
    # or complain if level > 0 and no timestamp
    # or use the epoch for level 0
    if ($targetfile ne '') {
        chomp($_ = `date -r $targetfile +%Y%m%d%H%M.%S`);
        return($_);

    } elsif ($level eq "0") {
        return('197001010000.00');

    } else {
        die("Can't do a level $level backup - no level 0 timestamp found\n");

    }

}

######################################################################
# Echo message to screen and log
######################################################################
sub log {

    my $msg = shift(@_);

    print "$msg\n";
    if (defined($global::log)) {
        open(LOG,">>$global::log");
        print LOG "$msg\n";
        close(LOG);
    }

}

######################################################################
# Echo a line to both screen and log
######################################################################
sub line {
    print "---------------------------------------\n";
    if (defined($global::log)) {
        open(LOG,">>$global::log");
        print LOG "---------------------------------------\n";
        close(LOG);
    }
}

######################################################################
# Read configuration file
######################################################################
sub readconfigfile {

    my $configfile;
    my $var;
    my $value;
    my $defines = $global::opt{'d'};

    if (defined($global::opt{'c'})) {
        $configfile = $global::opt{'c'};
    } else {
        $configfile = "/etc/flexbackup.conf";
    }
    if (! -r $configfile) {
        die("config file $configfile: $!\n");
    }
    system("perl -c $configfile 2>&1");
    if ($?) {
        die("syntax error in config file $configfile\n");
    }

    package cfg;
    require "$configfile";
    package global;

    # Overrides
    foreach $var (keys %$defines) {
        $value = $$defines{$var};
        &log("(override) $var = $value");
        eval("\$cfg::$var=\"$value\"");
    }

}

######################################################################
# Do a tape operation
######################################################################
sub mt {

    my $operation = shift(@_);

    # mt & ftmt slightly different
    if ($operation eq 'generic-query') {
        if ($cfg::ftape eq 'true') {
            $operation = 'getsize';
        } else {
            $operation = 'status';
        }
    }

    # mt & ftmt slightly different
    if ($operation eq 'generic-eod') {
        if ($cfg::ftape eq 'true') {
            $operation = 'eom';
        } else {
            $operation = 'eod';
        }
    }

    # BSD mt is slightly different
    if ($operation =~ /generic-blksize/) {
        if ($global::uname =~ /BSD/) {
            $operation =~ s/generic-blksize/blocksize/;
        } else {
            $operation =~ s/generic-blksize/setblk/;
        }
    }

    if (defined($global::use_file)) {
        &log("Archiving to file; \"mt $operation\" skipped");
    } elsif (defined($global::opt{'n'})) {
        &log("(debug) $global::mt -f $cfg::device $operation");
    } else {
        if (defined($global::log)) {
            system("$global::mt -f $cfg::device $operation 2>&1 | tee -a $global::log");
        } else {
            system("$global::mt -f $cfg::device $operation 2>&1");
        }
        if ($?) {
            &log("Error from $global::mt $operation\n");
            exit(1);
        }
    }
}

######################################################################
# Option error checking
######################################################################
sub optioncheck {

    # archive type on commandline
    if (defined($global::opt{'type'})) {
        $cfg::type = $global::opt{'type'};
    }

    # check device (or dir)
    if (-c $cfg::device) {
        # ok
    } elsif (-d $cfg::device) {
        $global::use_file = 1;
        $cfg::device =~ s:/$::; # nuke trailing slash

    } else {
        die("\$device must be set to a directory or a device\n");
    }

    # can we write to it?
    if (! -w $cfg::device) {
        die("Can't write to $cfg::device\n");
    }

    # ftape support
    if (defined($cfg::ftape)) {
	if ($cfg::ftape eq 'true') {
	    $global::mt = 'ftmt';
	} elsif ($cfg::ftape eq 'false') {
	    $global::mt = 'mt';
	} else {
	    die("config file error: \$ftape must be defined as true or false\n");
	}
    } else {
	die("config file error: \$ftape must be defined as true or false\n");
    }

    # blksize
    if (defined($cfg::blksize)) {
        if ($cfg::blksize !~ m/^\d+$/) {
            die("config file error: \$blksize must be set to integer\n");
        } else {
            if ($cfg::blksize < 10) {
                die("config file error: \$blksize minimum is 10k\n");
            }
        }
    }

    # filesystems
    $global::num_tapes = 0;
    foreach (@cfg::filesystems) {
        $global::num_tapes++;
    }
    if ($global::num_tapes == 0) {
        die("config file error: no filesystem spec for \"all\" backups");
    }


    # Type-specific setup
    if (defined($cfg::type)) {

	if ($cfg::type eq 'afio') {

            # Compress flag
            if ($cfg::afio_compress eq "true") {
                $cfg::afio_compress = "-Z";
            } else {
                $cfg::afio_compress = "";
            }

            # Verbose flag
            if ($cfg::afio_verbose eq "true") {
                $cfg::afio_verbose = "-v -z";
            } else {
                $cfg::afio_verbose = "";
            }

            # Length of tape
            if (defined($cfg::afio_length)) {
                if ($cfg::afio_length =~ m/^\d+$/) {
                    $cfg::afio_length .= "k";
                } else {
                    die("config file error: \$afio_length must be set to integer number of megabytes\n");
                }

            } else {
                die("config file error: \$afio_length not defined\n");
            }

            # Double buffer flag
            if ($cfg::afio_doublebuffer eq "true") {
                $cfg::afio_doublebuffer = "-f";
                if ($cfg::afio_length eq "0k") {
                    die("config file error: afio_length must be nonzero if doublebuffer is on\n");
                }
            } else {
                $cfg::afio_doublebuffer = "";
            }

            # For afio, blocksize needs k appended
            $cfg::afio_blksize = $cfg::blksize . "k";

            # Really need buffer in units of blksize not k
            if (defined($cfg::afio_buffer)) {
                if ($cfg::afio_buffer =~ m/^\d+$/) {
                    if (($cfg::afio_buffer % $cfg::blksize) != 0) {
                        die("config file error: \$afio_buffer must be multiple of \$blksize\n");
                    }
                    $cfg::afio_buffer = $cfg::afio_buffer / $cfg::blksize;
                } else {
                    die("config file error: \$afio_buffer must be set to integer number of kilobytes\n");
                }
            }


	} elsif ($cfg::type eq 'dump') {

            # use /etc/dumpdates?
            if (defined($cfg::dump_dumpdates)) {
                if ($cfg::dump_dumpdates !~ /^(true|false)$/) {
                    die("config file error: \$dump_dumpdates must be defined as true or false\n");
                }
            }

            # Length of tape
            if (defined($cfg::dump_length)) {
                if ($cfg::dump_length =~ m/^\d+$/) {
                    # Really need buffer in units of blksize not k
                    #
                    # Huh? this seems to be a bogus req, B flag is always
                    # taken in k. Is the man page for dump wrong?
                    #if (($cfg::dump_length % $cfg::blksize) != 0) {
                    #    die("config file error: \$dump_length must be multiple of \$blksize\n");
                    #}
                    #$cfg::dump_length = $cfg::dump_length / $cfg::blksize;
                } else {
                    die("config file error: \$dump_length must be set to integer number of kilobytes\n");
                }

            } else {
                die("config file error: \$dump_length not defined\n");
            }

	} elsif ($cfg::type eq 'tar') {

            # Compress flag
            if ($cfg::tar_compress eq "true") {
                $cfg::tar_compress = "-z";
            } else {
                $cfg::tar_compress = "";
            }

            # Verbose flag
            if ($cfg::tar_verbose eq "true") {
                $cfg::tar_verbose = "-v --totals";
            } else {
                $cfg::tar_verbose = "";
            }

            # For tar, blocks are in 512-byte units
            # not 1024 (1k) like dump, afio
            $cfg::tar_blksize = $cfg::blksize * 2;

	} elsif ($cfg::type eq 'cpio') {

            # Verbose flag
            if ($cfg::cpio_verbose eq "true") {
                $cfg::cpio_verbose = "-v";
            } else {
                $cfg::cpio_verbose = "";
            }

            # For cpio, blocks are in bytes
            # not 1024 (1k) like dump, afio
            $cfg::cpio_blksize = $cfg::blksize * 1024;

	} else {
	    die("config file error: \$type must be defined as afio, dump, tar, or cpio\n");
	}
    } else {
	die("config file error: \$type must be defined as afio, dump, tar, or cpio\n");
    }

    # log/stamp files
    if (defined($cfg::logdir)) {
	if (! -d $cfg::logdir) {
            mkdir("$cfg::logdir",0755) or die("Can't mkdir $cfg::logdir: $!");
	}
    } else {
	die("config file error: \$logdir must be defined\n");
    }
    if (defined($cfg::stampdir)) {
        if (! -d $cfg::stampdir) {
            mkdir("$cfg::stampdir",0755) or die("Can't mkdir $cfg::stampdir: $!");
        }
    } else {
        die("config file error: \$stampdir must be defined\n");
    }

    # levels
    if (defined($global::opt{'level'})) {
        if ($global::opt{'level'} !~ m/^\d$/) {
            die("-level must be 0 through 9 only\n");
        }
    }

    # mode
    my (@modelist) = qw(fs list extract compare restore toc);
    my @modes;
    my $modecount = 0;
    foreach (@modelist) {
        if (defined($global::opt{$_})) {
            $modecount++;
            push(@modes,$_);
        }
    }
    if ($modecount > 1) {
        $_ = join(" -",@modes);
        die("Can't specify more than one mode (given \"-$_\")\n");
    }
    if ($modecount == 0) {
        die("Nothing to do!\n");
    }

    # gzip
    if (defined($cfg::gzip_log)) {
        if ($cfg::gzip_log !~ /^(true|false)$/) {
            die("config file error: \$gzip_log must be defined as true or false\n");
        }
    }

    # test
    if (defined($global::opt{'n'})) {
        &log('(debug) no backup or mt commands will be executed');
    }


}

######################################################################
# Print usage summary from the header
######################################################################
sub usage {

    open(FILE,"$0") or die "Can't open $0: $!\n";
    while(<FILE>) {
	last if (m/^\#\s+USAGE:/);
    }
    while(<FILE>) {
	last if (m/^\#\#\#\#\#\#\#/);
	s/^\#//;
	print;
    }
    close(FILE);

}

######################################################################
# Return version string form CVS tag
######################################################################
sub versionstring {

    my $ver = ' $Name$ ';
    $ver =~ s/Name//g;
    $ver =~ s/[:\$]//g;
    $ver =~ s/\s+//g;
    $ver =~ s/^v//g;
    $ver =~ s/_/\./g;
    if ($ver eq '') {
        $ver = "devel";
    }
    return($ver);

}

######################################################################
# Return current time in YYYYMMDDHHMM.SS format
######################################################################
sub current_time {

    my $string;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);

    $year += 1900; # year from localtime has 1900 subtracted
    $mon += 1; # month from localtime starts at 0

    $string = sprintf("%04d",$year) . sprintf("%02d",$mon) . sprintf("%02d",$mday);
    $string .= sprintf("%02d",$hour) . sprintf("%02d",$min) . "." . sprintf("%02d",$sec);

    return($string);
}

######################################################################
# Possibly Return a filename to use
# if running list/extract/compare/restore
######################################################################
sub maybe_get_filename {

    my @modes = qw(list extract compare restore);
    my $arg;
    my $file;
    my $ftype;

    # optionscheck already guarantees only one is set
    foreach (@modes) {
        if (defined($global::opt{$_})) {
            $arg = $global::opt{$_};
        }
    }

    # if the flag given but null , and $device was not set to a dir, just return
    if (($arg eq '') and (!defined($global::use_file))) {
        return($cfg::device);
    }

    # Look for file in current dir first (or full path given)
    # Then in $device dir (if conf file set to backup to files)
    if (-f "$arg") {
        $file = $arg;
        $global::use_file = 1;

    } elsif (defined($global::use_file) and (-f "$cfg::device/$arg")) {
        $file = $cfg::device . "/" . $arg;

    } else {
        if (defined($global::use_file)) {
            die("Error: file \"$arg\" or \"$cfg::device/$arg\" not found\n");
        } else {
            die("Error: file \"$arg\" not found\n");
        }
    }

    return($file);

}

######################################################################
# Update table of contents
######################################################################
sub update_toc {

    # Only ftape has the toc capability
    if ($cfg::ftape eq 'true') {
        &log('Updating table of contents...');
        foreach (keys %global::contents) {
            &tag($_,$global::contents{$_});
        }
    }
}
